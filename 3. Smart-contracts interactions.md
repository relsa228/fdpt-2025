# Smart-contracts interactions
**Цель:** освоить принципы разработки смарт-контрактов на Solana.
## Теоретические данные
### SVM
Solana, как и некоторые другие современные блокчейны (вроде *Ethereum* и *TON*), имеет собственную виртуальную машину для выполнения смарт-контрактов, она называется **SVM**.

Копии SVM развернуты на каждом **валидаторе** и пропускают через себя все транзакции и программы (которые проходят через данный валидатор), выполняя их **байткод** на локальном снимке состояния сети. После выполнения блоков результаты проверяются остальными участниками сети и применяются, если достигнут консенсус.

То есть SVM **не находится** на каком-то одном центральном сервере, а представляет собой скорее изолированную среду выполнения (собственно говоря, виртуальную машину), которая разворачивается вместе с каждым новым валидатором. Это позволяет сети нормально функционировать даже в случае компрометации SVM на некотором узле, предотвращая таким образом появление единой точки отказа.

Транзакции в Solana состоят из набора **инструкций** и явным образом указывают список **аккаунтов**, к которым нужен доступ. На уровне рантайма это позволяет **параллельно** исполнять независимые инструкции (если их аккаунты не конфликтуют) и блокировать аккаунты на чтение/запись для предотвращения гонок. Исполнение детерминировано и ограничено лимитом **compute units (CU)**.
### sBPF
Последнее, что стоит упомянуть про SVM – ее работа с **байткодом**. В отличии от EVM, SVM работает не только с байткодом нативного языка, но и с любым другим, который поддерживает **LLVM** и **BPF** бэкенды. Дело в том, что Solana использует LLVM для компиляции программы в ELF файлы. Эти файлы содержат в себе собственную версию eBPF байткода, который называется **sBPF**, этот диалект немного ограничивает возможности eBPF, делая исполнение более предсказуемым и безопасным.
В итоге цепочка сборки выглядит так:

Rust (или другой язык с поддержкой **LLVM**) → LLVM IR → eBPF → **ELF‑файл** с байткодом.

Ончейн размещается именно **ELF с sBPF‑байткодом**, который загружается и исполняется специальной программой‑загрузчиком (BPF Upgradeable Loader).
### Solana Programs
В Solana смарт-контракты называют просто **программами** (*programs*). Программы размещаются в сети на **аккаунтах** (они имеют флаг **executable**), которые хранят в себе скомпилированные исполняемые [бинарные файлы](#sBPF). Метаданные программы хранятся на аккаунте **Program Data**.

Для взаимодействия с программой пользователю необходимо отправить на ее аккаунт транзакцию, которая содержит набор **инструкций**, которые уже определят, что именно программа должна сделать.

Программы можно обновлять, это может делать аккаунт, который отмечен в метаданных программы как *upgrade authority*. Если доступ к этому аккаунту утерян или в метаданных программы *upgrade authority* выставлен как *None*, то программа становится неизменяемой.

Программы в Solana как правило **stateless** (не хранят состояния): состояние размещается в обычных аккаунтах‑данных, владельцем которых является программа (или PDA‑аккаунты, производные от адреса программы).
### Anchor
С развитием блокчейн-индустрии написание смарт-контрактов стало одним из основных родов деятельности занятых там программистов. Это породило необходимость создания удобных инструментов создания, тестирования и доставки смарт-контрактов. В сети Solana наиболее популярным решением для этой задачи стал фреймворк Anchor.

**Anchor** – фреймворк для разработки программ Solana на Rust. Он сокращает затраты на разработку, добавляет безопасные абстракции и инструменты:
- декларативные проверки аккаунтов через `#[derive(Accounts)]` и атрибуты (`init`, `seeds`, `bump`, `payer`, `mut` и т. д.);
- сериализация/десериализация аккаунтов через `#[account]` и автоматический **дискриминатор** (первые 8 байт SHA‑256 от имени типа);
- удобная работа с **PDA** (seeds/bump);
- генерация **IDL**;
- **CLI** для сборки/тестирования/деплоя.
Вот базовый пример программы на Anchor:

```rust
use anchor_lang::prelude::*;

declare_id!("BYFW1vhC1ohxwRbYoLbAWs86STa25i9sD5uEusVjTYNd");

#[program]
mod hello_anchor {
    use super::*;

    pub fn initialize(ctx: Context<Initialize>, data: u64) -> Result<()> {
        ctx.accounts.new_account.data = data;
        msg!("Changed data to: {}!", data);
        Ok(())
    }
}

#[derive(Accounts)]
pub struct Initialize<'info> {
    #[account(init, payer = signer, space = 8 + 8)]
    pub new_account: Account<'info, NewAccount>,
    #[account(mut)]
    pub signer: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[account]
pub struct NewAccount {
    data: u64,
}
```
### IDL
Для взаимодействия anchor-программ с внешними клиентами существует специальный язык описания **Interface Description Language (IDL)**, на нем написан JSON-файл, который предоставляет внешнему клиенту полную информацию о программе, ее методах и аккаунтах. В инструкциях и аккаунтах также указываются 8‑байтовые **дискриминаторы** (первые 8 байт `sha256("global:<method>")` для инструкций и `sha256("account:<Type>")` для аккаунтов).
IDL файл для программы выше будет выглядеть так:

```JSON
{
  "address": "BYFW1vhC1ohxwRbYoLbAWs86STa25i9sD5uEusVjTYNd",
  "metadata": {
    "name": "hello_anchor",
    "version": "0.1.0",
    "spec": "0.1.0",
    "description": "Created with Anchor"
  },
  "instructions": [
    {
      "name": "initialize",
      "discriminator": [175, 175, 109, 31, 13, 152, 155, 237],
      "accounts": [
        {
          "name": "new_account",
          "writable": true,
          "signer": true
        },
        {
          "name": "signer",
          "writable": true,
          "signer": true
        },
        {
          "name": "system_program",
          "address": "11111111111111111111111111111111"
        }
      ],
      "args": [
        {
          "name": "data",
          "type": "u64"
        }
      ]
    }
  ],
  "accounts": [
    {
      "name": "NewAccount",
      "discriminator": [176, 95, 4, 118, 91, 177, 125, 232]
    }
  ],
  "types": [
    {
      "name": "NewAccount",
      "type": {
        "kind": "struct",
        "fields": [
          {
            "name": "data",
            "type": "u64"
          }
        ]
      }
    }
  ]
}
```

Это описание можно интегрировать например в Typescript код (просто поместить JSON-файл в папку с проектом, импортировать его и преобразовать в объект с помощью `@coral-xyz/anchor` ) и работать с описанной там программой как с обычным объектом:

```typescript
 const transactionSignature = await program.methods
      .initialize(data)
      .accounts({
        newAccount: newAccountKp.publicKey,
        signer: wallet.publicKey,
      })
      .signers([newAccountKp])
      .rpc();
```
### Глоссарий ключевых терминов
- **SVM (Solana Virtual Machine)** – виртуальная машина Solana, изолированная среда выполнения смарт-контрактов. Разворачивается на каждом валидаторе, обеспечивает детерминированное и параллельное выполнение транзакций.
- **Compute Units (CU)** – лимит вычислительных ресурсов, выделяемых на выполнение транзакции или инструкции в SVM.
- **Инструкция (instruction)** – элемент транзакции, описывающий конкретное действие и набор аккаунтов, необходимых для его выполнения.
- **Аккаунт (account)** – основной объект хранения данных в Solana. Может содержать токены, состояние программы или бинарный код (если имеет флаг `executable`).
- **sBPF (Solana Berkeley Packet Filter)** – модифицированный диалект eBPF, используемый Solana для безопасного и предсказуемого исполнения программ. Программы компилируются в ELF-файлы с sBPF-байткодом.
- **BPF Loader (BPF Upgradeable Loader)** – системная программа, отвечающая за загрузку и исполнение ELF-файлов с sBPF-байткодом. Поддерживает обновление программ при наличии _upgrade authority_.
- **Program (программа)** – эквивалент смарт-контракта в Solana. Размещается в аккаунте с флагом `executable`. Как правило, является _stateless_: состояние хранится в отдельных аккаунтах-данных или PDA.
- **Program Derived Address (PDA)** – детерминированный адрес аккаунта, производный от адреса программы и набора сидов. Используется для хранения состояния и обеспечения уникальности данных.
- **Anchor** – фреймворк для разработки программ Solana на Rust. Предоставляет удобные абстракции (валидация аккаунтов, сериализация, работа с PDA), генерацию IDL и CLI для сборки, тестирования и деплоя.
- **Discriminator (дискриминатор)** – первые 8 байт SHA-256-хэша от имени типа или метода. Автоматически добавляется Anchor для уникальной идентификации аккаунтов и инструкций.
- **IDL (Interface Description Language)** – JSON-описание Anchor-программы. Содержит информацию о методах, аргументах и аккаунтах, позволяя внешним клиентам (например, TypeScript-приложениям) взаимодействовать с программой как с обычным объектом.
### References
1. [Solana Virtual Machine (SVM)](https://coinmarketcap.com/academy/glossary/solana-virtual-machine-svm)
2. [What Is SVM - The Solana Virtual Machine](https://squads.so/blog/solana-svm-sealevel-virtual-machine)
3. [Solana Virtual Machine (SVM) Meaning](https://www.ledger.com/academy/glossary/solana-virtual-machine-svm)
4. [EVM vs. SVM: Smart Contracts](https://solana.com/developers/evm-to-svm/smart-contracts)
5. [Programs on Solana](https://solana.com/docs/core/programs)
6. [Intro to Anchor development](https://solana.com/developers/courses/onchain-development/intro-to-anchor)
## Задание
- **Установить Anchor CLI и создать проект.**
	- теперь можете использовать секцию про Anchor из [этого](https://solana.com/docs/intro/installation) гайда.
- **Реализовать смарт-контракт** *«Counter»**:*
    - `initialize` – создать аккаунт счётчика;
    - `increment` – увеличить значение счётчика;
    - `decrement` – уменьшить значение счётчика.
- **Скомпилировать и задеплоить контракт.**
- **Написать клиентский скрипт, который:**
    - вызывает `initialize`;
    - 3 раза вызывает `increment`;
    - 1 раз вызывает `decrement`;
    - выводит текущее значение счётчика в консоль.
- **Реализовать смарт-контракт для собственного DEX:**
	- контракт обменивает токен, созданный в предыдущей работе, на **WSOL** и обратно **по фиксированному** курсу;
	- `initialize` – создаёт пул *ВАШ_ТОКЕН/WSOL*. Пул должен выглядеть как новый аккаунт-счет с двумя привязанными к нему **ATA** (вашего токена и WSOL). При вызове инструкции `initialize` вы должны отправить контракту ликвидность (то есть некоторое количество вашего токена и WSOL) для наполнения пула;
    - `buy` – пользователь шлёт WSOL, получает ваши токены;
    - `sell` – пользователь шлёт ваши токены, получает WSOL.
    - курс для `buy` и `sell` фиксирован и определяется кодом программы (например, *ВАШ_ТОКЕН* == 0.5 *WSOL*)
- **Написать простой клиентский скрипт для проведения обменов.**
## Definition of done
- Оба контракта компилируются и деплоятся на локальный валидатор.
- IDL корректно сгенерированы и используются в клиенте.
- Все вызовы работают корректно.
- Код обоих клиентов структурирован и использует Anchor API.
